/*
 * Copyright 2021 Paul Rybitskyi, paul.rybitskyi.work@gmail.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.paulrybitskyi.hiltbinder.processor

import com.google.common.truth.Truth.assertThat
import com.paulrybitskyi.hiltbinder.BindType
import com.paulrybitskyi.hiltbinder.processor.javac.HiltBinderJavacProcessor
import com.paulrybitskyi.hiltbinder.processor.ksp.model.HiltComponent
import com.paulrybitskyi.hiltbinder.processor.ksp.model.PredefinedHiltComponent
import com.paulrybitskyi.hiltbinder.processor.ksp.parser.factories.ModuleInterfaceNameFactory
import com.paulrybitskyi.hiltbinder.processor.javac.model.WITH_FRAGMENT_BINDINGS_TYPE_CANON_NAME
import com.paulrybitskyi.hiltbinder.processor.ksp.parser.PredefinedHiltComponentMapper
import com.paulrybitskyi.hiltbinder.processor.ksp.parser.providers.MessageProvider
import com.tschuchort.compiletesting.KotlinCompilation
import com.tschuchort.compiletesting.KotlinCompilation.ExitCode
import com.tschuchort.compiletesting.SourceFile
import com.tschuchort.compiletesting.SourceFile.Companion.java
import org.junit.Test
import java.io.File

internal class HiltBinderJavacTest {


    private companion object {

        private val PREDEFINED_HILT_COMPONENT_MAPPER = PredefinedHiltComponentMapper()
        private val MODULE_INTERFACE_NAME_FACTORY = ModuleInterfaceNameFactory()
        private val MESSAGE_PROVIDER = MessageProvider()

        private val VALID_ANNOTATION_PREDEFINED_COMPONENTS = BindType.Component
            .values()
            .filter { (it != BindType.Component.NONE) && (it != BindType.Component.CUSTOM) }

        private val TESTABLE_FILE = java("Testable.java", "public interface Testable {}")
        private val ABSTRACT_TEST_FILE = java("AbstractTest.java", "public abstract class AbstractTest {}")

    }


    @Test
    fun `Binds class implicitly to its single interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType
                public class Test implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Testable bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly to its single interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = Testable.class)
                public class Test implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Testable bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class implicitly to its superclass`() {
        val compilation = setupCompilation(
            ABSTRACT_TEST_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType
                public class Test extends AbstractTest {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              AbstractTest bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly to its superclass`() {
        val compilation = setupCompilation(
            ABSTRACT_TEST_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = AbstractTest.class)
                public class Test extends AbstractTest {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              AbstractTest bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly, which has two interfaces, to specific interface`() {
        val compilation = setupCompilation(
            java(
                "Testable1.java",
                "public interface Testable1 {}"
            ),
            java(
                "Testable2.java",
                "public interface Testable2 {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = Testable1.class)
                public class Test implements Testable1, Testable2 {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Testable1 bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly, which has superclass and interface, to superclass`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            ABSTRACT_TEST_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = AbstractTest.class)
                public class Test extends AbstractTest implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              AbstractTest bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly, which has superclass and interface, to interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            ABSTRACT_TEST_FILE,
            java(
                "Test.java",
                """
                 import com.paulrybitskyi.hiltbinder.BindType;

                 @BindType(to = Testable.class)
                 public class Test extends AbstractTest implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Testable bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly to Object class`() {
        val compilation = setupCompilation(
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = Object.class)
                public class Test {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Object;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Object bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly, which has superclass, to Object class`() {
        val compilation = setupCompilation(
            ABSTRACT_TEST_FILE,
            java(
                "Test.java",
                """
                 import com.paulrybitskyi.hiltbinder.BindType;

                 @BindType(to = Object.class)
                 public class Test extends AbstractTest {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Object;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Object bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly, which has interface, to Object class`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = Object.class)
                public class Test implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Object;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Object bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly, which has superclass and interface, to Object class`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            ABSTRACT_TEST_FILE,
            java(
                "Test.java",
                """
                 import com.paulrybitskyi.hiltbinder.BindType;

                 @BindType(to = Object.class)
                 public class Test extends AbstractTest implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Object;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Object bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly, which has superclass, to its superclass's implemented interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "AbstractTest.java",
                "public abstract class AbstractTest implements Testable {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = Testable.class)
                public class Test extends AbstractTest {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Testable bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly, which has superclass, to its superclass's superclass`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "AbstractAbstractTest.java",
                "public abstract class AbstractAbstractTest {}"
            ),
            java(
                "AbstractTest.java",
                "public abstract class AbstractTest extends AbstractAbstractTest {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = AbstractAbstractTest.class)
                public class Test extends AbstractTest {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              AbstractAbstractTest bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly, which has interface, to its interface's base interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "UnitTestable.java",
                "public interface UnitTestable extends Testable {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = Testable.class)
                public class Test implements UnitTestable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Testable bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class implicitly to its parameterized interface`() {
        val compilation = setupCompilation(
            java(
                "Testable.java",
                "public interface Testable<T> {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType
                public class Test implements Testable<Long> {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Long;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Testable<Long> bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly to its direct parameterized interface`() {
        val compilation = setupCompilation(
            java(
                "Testable.java",
                "public interface Testable<T> {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = Testable.class)
                public class Test implements Testable<Long> {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Long;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Testable<Long> bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly to its indirect parameterized interface`() {
        val compilation = setupCompilation(
            java(
                "Testable.java",
                "public interface Testable<T> {}"
            ),
            java(
                "UnitTestable.java",
                "public interface UnitTestable extends Testable<Float> {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = Testable.class)
                public class Test implements UnitTestable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Float;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Testable<Float> bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class implicitly to its parameterized superclass`() {
        val compilation = setupCompilation(
            java(
                "AbstractTest.java",
                "public abstract class AbstractTest<T> {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType
                public class Test extends AbstractTest<Long> {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Long;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              AbstractTest<Long> bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly to its direct parameterized superclass`() {
        val compilation = setupCompilation(
            java(
                "AbstractTest.java",
                "public abstract class AbstractTest<T> {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = AbstractTest.class)
                public class Test extends AbstractTest<Long> {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Long;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              AbstractTest<Long> bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly to its indirect parameterized superclass`() {
        val compilation = setupCompilation(
            java(
                "AbstractAbstractTest.java",
                "public abstract class AbstractAbstractTest<T> {}"
            ),
            java(
                "AbstractTest.java",
                "public abstract class AbstractTest extends AbstractAbstractTest<Integer> {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = AbstractAbstractTest.class)
                public class Test extends AbstractTest {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Integer;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              AbstractAbstractTest<Integer> bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class to heavily parameterized type`() {
        val compilation = setupCompilation(
            java(
                "Testable.java",
                "public interface Testable<T1, T2, T3> {}"
            ),
            java(
                "Testable1.java",
                "public interface Testable1<T1, T2, T3> {}"
            ),
            java(
                "Testable2.java",
                "public interface Testable2<T1, T2, T3> {}"
            ),
            java(
                "Testable3.java",
                "public interface Testable3<T1, T2, T3> {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = Testable.class)
                public class Test implements Testable<
                  Testable1<? super Integer, ? super Float, ? super String>,
                  Testable2<? extends Integer, ? extends Float, ? extends String>,
                  Testable3<?, ?, ?>
                > {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Float;
            import java.lang.Integer;
            import java.lang.String;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Testable<Testable1<? super Integer, ? super Float, ? super String>, Testable2<? extends Integer, ? extends Float, ? extends String>, Testable3<?, ?, ?>> bind_Test(
                  Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Fails to bind class implicitly, which does not have superclass or interface`() {
        val compilation = setupCompilation(
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType
                public class Test {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.undefinedReturnTypeError())
    }


    @Test
    fun `Fails to bind class implicitly, which has two interfaces`() {
        val compilation = setupCompilation(
            java(
                "Testable1.java",
                "public interface Testable1 {}"
            ),
            java(
                "Testable2.java",
                "public interface Testable2 {}"
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType
                public class Test implements Testable1, Testable2 {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.undefinedReturnTypeError())
    }


    @Test
    fun `Fails to bind class implicitly, which has superclass and interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            ABSTRACT_TEST_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType
                public class Test extends AbstractTest implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.undefinedReturnTypeError())
    }


    @Test
    fun `Fails to bind class explicitly, which does not have superclass or interface, to interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = Testable.class)
                public class Test {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.noSubtypeRelationError("Test", "Testable"))
    }


    @Test
    fun `Fails to bind class explicitly, which does not have superclass or interface, to class`() {
        val compilation = setupCompilation(
            ABSTRACT_TEST_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(to = AbstractTest.class)
                public class Test {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.noSubtypeRelationError("Test", "AbstractTest"))
    }


    @Test
    fun `Installs binding in predefined component, which is inferred from scope annotation`() {
        for(component in PredefinedHiltComponent.values()) {
            val isViewWithFragmentComponent = (component == PredefinedHiltComponent.VIEW_WITH_FRAGMENT)
            val withFragmentBindingAnnotation = if(isViewWithFragmentComponent) {
                "@$WITH_FRAGMENT_BINDINGS_TYPE_CANON_NAME"
            } else {
                ""
            }
            val predefinedHiltComponent = HiltComponent.Predefined(component)
            val interfaceName = MODULE_INTERFACE_NAME_FACTORY.createInterfaceName(predefinedHiltComponent)
            val compilation = setupCompilation(
                TESTABLE_FILE,
                java(
                    "Test.java",
                    """
                    import com.paulrybitskyi.hiltbinder.BindType;
                    
                    @${component.scopeQualifiedName}
                    $withFragmentBindingAnnotation
                    @BindType
                    public class Test implements Testable {}
                    """.trimIndent()
                )
            )
            val result = compilation.compile()
            val generatedModule = compilation.getGeneratedFile("$interfaceName.java")

            assertThat(result.exitCode).isEqualTo(ExitCode.OK)
            assertThat(generatedModule.exists()).isTrue()
            assertThat(generatedModule.readText()).isEqualTo(
                """
                // Generated by @BindType. Do not modify!
                
                import dagger.Binds;
                import dagger.Module;
                import dagger.hilt.InstallIn;
                import ${component.qualifiedName};
                
                @Module
                @InstallIn(${component.simpleName}.class)
                public interface $interfaceName {
                  @Binds
                  Testable bind_Test(Test binding);
                }
                """.trimIndent()
            )
        }
    }


    @Test
    fun `Installs binding in predefined component, which is explicitly specified in annotation`() {
        for(predefinedComponent in VALID_ANNOTATION_PREDEFINED_COMPONENTS) {
            val mappedComponent = PREDEFINED_HILT_COMPONENT_MAPPER.mapToPredefinedComponent(predefinedComponent)
            val predefinedHiltComponent = HiltComponent.Predefined(mappedComponent)
            val interfaceName = MODULE_INTERFACE_NAME_FACTORY.createInterfaceName(predefinedHiltComponent)
            val compilation = setupCompilation(
                TESTABLE_FILE,
                java(
                    "Test.java",
                    """
                    import com.paulrybitskyi.hiltbinder.BindType;
                    
                    @BindType(installIn = BindType.Component.${predefinedComponent.name})
                    public class Test implements Testable {}
                    """.trimIndent()
                )
            )
            val result = compilation.compile()
            val generatedModule = compilation.getGeneratedFile("$interfaceName.java")

            assertThat(result.exitCode).isEqualTo(ExitCode.OK)
            assertThat(generatedModule.exists()).isTrue()
            assertThat(generatedModule.readText()).isEqualTo(
                """
                // Generated by @BindType. Do not modify!
                
                import dagger.Binds;
                import dagger.Module;
                import dagger.hilt.InstallIn;
                import ${mappedComponent.qualifiedName};
                
                @Module
                @InstallIn(${mappedComponent.simpleName}.class)
                public interface $interfaceName {
                  @Binds
                  Testable bind_Test(Test binding);
                }
                """.trimIndent()
            )
        }
    }


    @Test
    fun `Installs binding in predefined component, which is specified both by the scope annotation and explicitly`() {
        for(predefinedComponent in VALID_ANNOTATION_PREDEFINED_COMPONENTS) {
            val mappedComponent = PREDEFINED_HILT_COMPONENT_MAPPER.mapToPredefinedComponent(predefinedComponent)
            val isViewWithFragmentComponent = (mappedComponent == PredefinedHiltComponent.VIEW_WITH_FRAGMENT)
            val withFragmentBindingAnnotation = if(isViewWithFragmentComponent) {
                "@$WITH_FRAGMENT_BINDINGS_TYPE_CANON_NAME"
            } else {
                ""
            }
            val predefinedHiltComponent = HiltComponent.Predefined(mappedComponent)
            val interfaceName = MODULE_INTERFACE_NAME_FACTORY.createInterfaceName(predefinedHiltComponent)
            val compilation = setupCompilation(
                TESTABLE_FILE,
                java(
                    "Test.java",
                    """
                    import com.paulrybitskyi.hiltbinder.BindType;
                    
                    @${mappedComponent.scopeQualifiedName}
                    $withFragmentBindingAnnotation
                    @BindType(installIn = BindType.Component.${predefinedComponent.name})
                    public class Test implements Testable {}
                    """.trimIndent()
                )
            )
            val result = compilation.compile()
            val generatedModule = compilation.getGeneratedFile("$interfaceName.java")

            assertThat(result.exitCode).isEqualTo(ExitCode.OK)
            assertThat(generatedModule.exists()).isTrue()
            assertThat(generatedModule.readText()).isEqualTo(
                """
                // Generated by @BindType. Do not modify!
                
                import dagger.Binds;
                import dagger.Module;
                import dagger.hilt.InstallIn;
                import ${mappedComponent.qualifiedName};
                
                @Module
                @InstallIn(${mappedComponent.simpleName}.class)
                public interface $interfaceName {
                  @Binds
                  Testable bind_Test(Test binding);
                }
                """.trimIndent()
            )
        }
    }


    @Test
    fun `Fails to install binding in predefined component, when scope's component and explicit component differs`() {
        for(predefinedComponent in VALID_ANNOTATION_PREDEFINED_COMPONENTS) {
            val mappedComponent = PREDEFINED_HILT_COMPONENT_MAPPER.mapToPredefinedComponent(predefinedComponent)
            val isViewWithFragmentComponent = (mappedComponent == PredefinedHiltComponent.VIEW_WITH_FRAGMENT)
            val withFragmentBindingAnnotation = if(isViewWithFragmentComponent) {
                "@$WITH_FRAGMENT_BINDINGS_TYPE_CANON_NAME"
            } else {
                ""
            }
            val mismatchedExplicitComponent = when(mappedComponent) {
                PredefinedHiltComponent.SINGLETON -> PredefinedHiltComponent.ACTIVITY_RETAINED
                PredefinedHiltComponent.ACTIVITY_RETAINED -> PredefinedHiltComponent.SERVICE
                PredefinedHiltComponent.SERVICE -> PredefinedHiltComponent.ACTIVITY
                PredefinedHiltComponent.ACTIVITY -> PredefinedHiltComponent.VIEW_MODEL
                PredefinedHiltComponent.VIEW_MODEL -> PredefinedHiltComponent.FRAGMENT
                PredefinedHiltComponent.FRAGMENT -> PredefinedHiltComponent.VIEW
                PredefinedHiltComponent.VIEW -> PredefinedHiltComponent.VIEW_WITH_FRAGMENT
                PredefinedHiltComponent.VIEW_WITH_FRAGMENT -> PredefinedHiltComponent.SINGLETON
            }
            val compilation = setupCompilation(
                TESTABLE_FILE,
                java(
                    "Test.java",
                    """
                    import com.paulrybitskyi.hiltbinder.BindType;
                    
                    @${mappedComponent.scopeQualifiedName}
                    $withFragmentBindingAnnotation
                    @BindType(installIn = BindType.Component.${mismatchedExplicitComponent.name})
                    public class Test implements Testable {}
                    """.trimIndent()
                )
            )
            val result = compilation.compile()

            assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
            assertThat(result.messages).contains(MESSAGE_PROVIDER.componentMismatchError())
        }
    }


    @Test
    fun `Installs scoped binding in custom component successfully`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "CustomScope.java",
                """
                import java.lang.annotation.RetentionPolicy;

                import java.lang.annotation.Retention;
                import javax.inject.Scope;

                @Scope
                @Retention(RetentionPolicy.RUNTIME)
                public @interface CustomScope {}
                """.trimIndent()
            ),
            java(
                "CustomComponent.java",
                """
                import dagger.hilt.DefineComponent;
                import dagger.hilt.components.SingletonComponent;

                @CustomScope
                @DefineComponent(parent = SingletonComponent.class)
                public interface CustomComponent {}
                """.trimIndent()
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(
                  installIn = BindType.Component.CUSTOM,
                  customComponent = CustomComponent.class
                )
                @CustomScope
                public class Test implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_CustomComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;

            @Module
            @InstallIn(CustomComponent.class)
            public interface HiltBinder_CustomComponentModule {
              @Binds
              Testable bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Installs unscoped binding in custom component successfully`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "CustomComponent.java",
                """
                import dagger.hilt.DefineComponent;
                import dagger.hilt.components.SingletonComponent;

                @DefineComponent(parent = SingletonComponent.class)
                public interface CustomComponent {}
                """.trimIndent()
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(
                  installIn = BindType.Component.CUSTOM,
                  customComponent = CustomComponent.class
                )
                public class Test implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_CustomComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;

            @Module
            @InstallIn(CustomComponent.class)
            public interface HiltBinder_CustomComponentModule {
              @Binds
              Testable bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Fails to install binding in custom component, when its type is unspecified`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(installIn = BindType.Component.CUSTOM)
                public class Test implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.undefinedCustomComponentError())
    }


    @Test
    fun `Binds class with predefined qualifier`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                import javax.inject.Named;

                @Named("test")
                @BindType(withQualifier = true)
                public class Test implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import javax.inject.Named;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @Named("test")
              Testable bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class with custom qualifier`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "CustomQualifier.java",
                """
                import java.lang.annotation.Retention;
                import java.lang.annotation.RetentionPolicy;

                import javax.inject.Qualifier;

                @Qualifier
                @Retention(RetentionPolicy.RUNTIME)
                public @interface CustomQualifier {

                  Type type();

                  enum Type { ONE }

                }
                """.trimIndent()
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @CustomQualifier(type = CustomQualifier.Type.ONE)
                @BindType(withQualifier = true)
                public class Test implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @CustomQualifier(
                  type = CustomQualifier.Type.ONE
              )
              Testable bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Fails to bind class, which is specified to have qualifier, but does not have it`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(withQualifier = true)
                public class Test implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.qualifierAbsentError())
    }


    @Test
    fun `Verify that all annotation properties are properly copied in binding method`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "CustomQualifierType.java",
                "public enum CustomQualifierType { ONE, TWO, THREE }"
            ),
            java(
                "InnerAnno.java",
                """
                import java.lang.annotation.Retention;
                import java.lang.annotation.RetentionPolicy;

                @Retention(RetentionPolicy.RUNTIME)
                public @interface InnerAnno {

                  int intValue();
                  long longValue();
                  Class<?> classValue();

                }
                """.trimIndent()
            ),
            java(
                "CustomQualifierClass.java",
                "public class CustomQualifierClass {}"
            ),
            java(
                "CustomQualifier.java",
                """
                import java.lang.annotation.Retention;
                import java.lang.annotation.RetentionPolicy;

                import javax.inject.Qualifier;

                @Qualifier
                @Retention(RetentionPolicy.RUNTIME)
                public @interface CustomQualifier {

                  boolean boolValue();
                  char charValue();
                  byte byteValue();
                  short shortValue();
                  int intValue();
                  long longValue();
                  float floatValue();
                  double doubleValue();
                  String stringValue();
                  CustomQualifierType enumValue();
                  InnerAnno annotationValue();
                  Class<?> classValue();
                  boolean[] boolArray();
                  byte[] byteArray();
                  char[] charArray();
                  short[] shortArray();
                  int[] intArray();
                  long[] longArray();
                  float[] floatArray();
                  double[] doubleArray();
                  String[] stringArray();
                  CustomQualifierType[] enumArray();
                  InnerAnno[] annotationArray();
                  Class<?>[] classArray();

                }
                """.trimIndent()
            ),
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @CustomQualifier(
                  boolValue = true,
                  byteValue = 10,
                  charValue = ',',
                  shortValue = Short.MAX_VALUE,
                  intValue = -10,
                  longValue = 100L,
                  floatValue = -15f,
                  doubleValue = 50.0,
                  stringValue = "string",
                  enumValue = CustomQualifierType.ONE,
                  annotationValue = @InnerAnno(
                    intValue = 0,
                    longValue = 500L,
                    classValue = CustomQualifierClass.class
                  ),
                  classValue = CustomQualifierClass.class,
                  boolArray = { true, false },
                  byteArray = { 100, 105 },
                  charArray = { 'A', 'B', 'C' },
                  shortArray = { Short.MIN_VALUE, Short.MAX_VALUE },
                  intArray = { 0, 10, 20 },
                  longArray = { 10L, 20L, 30L },
                  floatArray = { Float.MAX_VALUE, Float.MIN_VALUE },
                  doubleArray = { 100.0, 200.0, 300.0 },
                  stringArray = { "one", "two", "three" },
                  enumArray = {
                    CustomQualifierType.ONE,
                    CustomQualifierType.TWO,
                    CustomQualifierType.THREE
                  },
                  annotationArray = {
                    @InnerAnno(
                      intValue = 0,
                      longValue = 1L,
                      classValue = Integer.class
                    ),
                    @InnerAnno(
                      intValue = 10,
                      longValue = 100L,
                      classValue = Float.class
                    )
                  },
                  classArray = {
                    Boolean.class,
                    Integer.class,
                    Double.class
                  }
                )
                @BindType(withQualifier = true)
                public class Test implements Testable { }
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import java.lang.Boolean;
            import java.lang.Double;
            import java.lang.Float;
            import java.lang.Integer;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @CustomQualifier(
                  boolValue = true,
                  byteValue = 10,
                  charValue = ',',
                  shortValue = 32767,
                  intValue = -10,
                  longValue = 100,
                  floatValue = -15.0f,
                  doubleValue = 50.0,
                  stringValue = "string",
                  enumValue = CustomQualifierType.ONE,
                  annotationValue = @InnerAnno(intValue = 0, longValue = 500, classValue = CustomQualifierClass.class),
                  classValue = CustomQualifierClass.class,
                  boolArray = {
                      true,
                      false
                  },
                  byteArray = {
                      100,
                      105
                  },
                  charArray = {
                      'A',
                      'B',
                      'C'
                  },
                  shortArray = {
                      -32768,
                      32767
                  },
                  intArray = {
                      0,
                      10,
                      20
                  },
                  longArray = {
                      10,
                      20,
                      30
                  },
                  floatArray = {
                      3.4028235E38f,
                      1.4E-45f
                  },
                  doubleArray = {
                      100.0,
                      200.0,
                      300.0
                  },
                  stringArray = {
                      "one",
                      "two",
                      "three"
                  },
                  enumArray = {
                      CustomQualifierType.ONE,
                      CustomQualifierType.TWO,
                      CustomQualifierType.THREE
                  },
                  annotationArray = {
                      @InnerAnno(intValue = 0, longValue = 1, classValue = Integer.class),
                      @InnerAnno(intValue = 10, longValue = 100, classValue = Float.class)
                  },
                  classArray = {
                      Boolean.class,
                      Integer.class,
                      Double.class
                  }
              )
              Testable bind_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Saves bound classes into multibound set`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test1.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(contributesTo = BindType.Collection.SET)
                public class Test1 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(contributesTo = BindType.Collection.SET)
                public class Test2 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(contributesTo = BindType.Collection.SET)
                public class Test3 implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import dagger.multibindings.IntoSet;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoSet
              Testable bind_Test1(Test1 binding);

              @Binds
              @IntoSet
              Testable bind_Test2(Test2 binding);

              @Binds
              @IntoSet
              Testable bind_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Saves bound parameterized classes into multibound set`() {
        val compilation = setupCompilation(
            java(
                "Testable.java",
                "public interface Testable<T1> {}"
            ),
            java(
                "Test1.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(contributesTo = BindType.Collection.SET)
                public class Test1 implements Testable<Integer> {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                 import com.paulrybitskyi.hiltbinder.BindType;

                 @BindType(contributesTo = BindType.Collection.SET)
                 public class Test2 implements Testable<Long> {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(contributesTo = BindType.Collection.SET)
                public class Test3 implements Testable<Float> {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import dagger.multibindings.IntoSet;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoSet
              Testable<?> bind_Test1(Test1 binding);

              @Binds
              @IntoSet
              Testable<?> bind_Test2(Test2 binding);

              @Binds
              @IntoSet
              Testable<?> bind_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Saves bound classes into qualified multibound set`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test1.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                import javax.inject.Named;

                @Named("one")
                @BindType(
                  contributesTo = BindType.Collection.SET,
                  withQualifier = true
                )
                public class Test1 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                import javax.inject.Named;

                @Named("two")
                @BindType(
                  contributesTo = BindType.Collection.SET,
                  withQualifier = true
                )
                public class Test2 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                 import com.paulrybitskyi.hiltbinder.BindType;

                 import javax.inject.Named;

                 @Named("three")
                 @BindType(
                   contributesTo = BindType.Collection.SET,
                   withQualifier = true
                 )
                 public class Test3 implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import dagger.multibindings.IntoSet;
            import javax.inject.Named;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoSet
              @Named("one")
              Testable bind_Test1(Test1 binding);

              @Binds
              @IntoSet
              @Named("two")
              Testable bind_Test2(Test2 binding);

              @Binds
              @IntoSet
              @Named("three")
              Testable bind_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Fails to save bound class, which does not have @MapKey annotation, into multibound map`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.noMapKeyError())
    }


    @Test
    fun `Saves bound classes into multibound map using standard integer key annotation`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test1.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapIntKey;

                @MapIntKey(1)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test1 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapIntKey;

                @MapIntKey(2)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test2 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapIntKey;

                @MapIntKey(3)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test3 implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapIntKey;
            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import dagger.multibindings.IntoMap;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapIntKey(1)
              Testable bind_Test1(Test1 binding);

              @Binds
              @IntoMap
              @MapIntKey(2)
              Testable bind_Test2(Test2 binding);

              @Binds
              @IntoMap
              @MapIntKey(3)
              Testable bind_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Saves bound classes into multibound map using standard long key annotation`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test1.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapLongKey;

                @MapLongKey(1L)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test1 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapLongKey;

                @MapLongKey(2L)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test2 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapLongKey;

                @MapLongKey(3L)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test3 implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapLongKey;
            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import dagger.multibindings.IntoMap;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapLongKey(1)
              Testable bind_Test1(Test1 binding);

              @Binds
              @IntoMap
              @MapLongKey(2)
              Testable bind_Test2(Test2 binding);

              @Binds
              @IntoMap
              @MapLongKey(3)
              Testable bind_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Saves bound classes into multibound map using standard string key annotation`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test1.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapStringKey;

                @MapStringKey("one")
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test1 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapStringKey;

                @MapStringKey("two")
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test2 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapStringKey;

                @MapStringKey("three")
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test3 implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapStringKey;
            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import dagger.multibindings.IntoMap;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapStringKey("one")
              Testable bind_Test1(Test1 binding);

              @Binds
              @IntoMap
              @MapStringKey("two")
              Testable bind_Test2(Test2 binding);

              @Binds
              @IntoMap
              @MapStringKey("three")
              Testable bind_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Saves bound classes into multibound map using standard class key annotation`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test1.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey;

                @MapClassKey(Test1.class)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test1 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey;

                @MapClassKey(Test2.class)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test2 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey;

                @MapClassKey(Test3.class)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test3 implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapClassKey;
            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import dagger.multibindings.IntoMap;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapClassKey(Test1.class)
              Testable bind_Test1(Test1 binding);

              @Binds
              @IntoMap
              @MapClassKey(Test2.class)
              Testable bind_Test2(Test2 binding);

              @Binds
              @IntoMap
              @MapClassKey(Test3.class)
              Testable bind_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Saves bound parameterized classes into multibound map using standard class key annotation`() {
        val compilation = setupCompilation(
            java(
                "Testable.java",
                "public interface Testable<T1, T2> {}"
            ),
            java(
                "Test1.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey;

                @MapClassKey(Test1.class)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test1 implements Testable<Long, Long> {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey;

                @MapClassKey(Test2.class)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test2 implements Testable<Integer, Integer> {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                 import com.paulrybitskyi.hiltbinder.BindType;
                 import com.paulrybitskyi.hiltbinder.keys.MapClassKey;

                 @MapClassKey(Test3.class)
                 @BindType(contributesTo = BindType.Collection.MAP)
                 public class Test3 implements Testable<Float, Float> {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapClassKey;
            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import dagger.multibindings.IntoMap;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapClassKey(Test1.class)
              Testable<?, ?> bind_Test1(Test1 binding);

              @Binds
              @IntoMap
              @MapClassKey(Test2.class)
              Testable<?, ?> bind_Test2(Test2 binding);

              @Binds
              @IntoMap
              @MapClassKey(Test3.class)
              Testable<?, ?> bind_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Saves bound classes into multibound map using custom @MapKey annotation`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "TestMapKey.java",
                """
                import java.lang.annotation.ElementType;
                import java.lang.annotation.Retention;
                import java.lang.annotation.RetentionPolicy;

                import dagger.MapKey;

                @MapKey
                @Retention(RetentionPolicy.RUNTIME)
                public @interface TestMapKey {

                  Type value();

                  enum Type { ONE, TWO, THREE }

                }
                """.trimIndent()
            ),
            java(
                "Test1.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @TestMapKey(TestMapKey.Type.ONE)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test1 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @TestMapKey(TestMapKey.Type.TWO)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test2 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @TestMapKey(TestMapKey.Type.THREE)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test3 implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import dagger.multibindings.IntoMap;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.ONE)
              Testable bind_Test1(Test1 binding);

              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.TWO)
              Testable bind_Test2(Test2 binding);

              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.THREE)
              Testable bind_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Saves bound parameterized classes into multibound map using custom @MapKey annotation`() {
        val compilation = setupCompilation(
            java(
                "Testable.java",
                "public interface Testable<T1, T2, T3> {}"
            ),
            java(
                "TestMapKey.java",
                """
                import java.lang.annotation.ElementType;
                import java.lang.annotation.Retention;
                import java.lang.annotation.RetentionPolicy;

                import dagger.MapKey;

                @MapKey
                @Retention(RetentionPolicy.RUNTIME)
                public @interface TestMapKey {

                  Type value();

                  enum Type { ONE, TWO, THREE }

                }
                """.trimIndent()
            ),
            java(
                "Test1.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @TestMapKey(TestMapKey.Type.ONE)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test1 implements Testable<Integer, Integer, Integer> {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @TestMapKey(TestMapKey.Type.TWO)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test2 implements Testable<Float, Float, Float> {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;

                @TestMapKey(TestMapKey.Type.THREE)
                @BindType(contributesTo = BindType.Collection.MAP)
                public class Test3 implements Testable<Double, Double, Double> {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import dagger.multibindings.IntoMap;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.ONE)
              Testable<?, ?, ?> bind_Test1(Test1 binding);

              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.TWO)
              Testable<?, ?, ?> bind_Test2(Test2 binding);

              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.THREE)
              Testable<?, ?, ?> bind_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Saves bound classes into qualified multibound map`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            java(
                "Test1.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey;

                import javax.inject.Named;

                @BindType(
                  contributesTo = BindType.Collection.MAP,
                  withQualifier = true
                )
                @MapClassKey(Test1.class)
                @Named("one")
                public class Test1 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey;

                import javax.inject.Named;

                @BindType(
                  contributesTo = BindType.Collection.MAP,
                  withQualifier = true
                )
                @MapClassKey(Test2.class)
                @Named("two")
                public class Test2 implements Testable {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                import com.paulrybitskyi.hiltbinder.BindType;
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey;

                import javax.inject.Named;

                @BindType(
                  contributesTo = BindType.Collection.MAP,
                  withQualifier = true
                )
                @MapClassKey(Test3.class)
                @Named("three")
                public class Test3 implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.java")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapClassKey;
            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import dagger.multibindings.IntoMap;
            import javax.inject.Named;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapClassKey(Test1.class)
              @Named("one")
              Testable bind_Test1(Test1 binding);

              @Binds
              @IntoMap
              @MapClassKey(Test2.class)
              @Named("two")
              Testable bind_Test2(Test2 binding);

              @Binds
              @IntoMap
              @MapClassKey(Test3.class)
              @Named("three")
              Testable bind_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Verify that binding method is properly formatted`() {
        val compilation = setupCompilation(
            java(
                "Testable.java",
                """
                package com.paulrybitskyi.hiltbinder.test;

                public interface Testable {}
                """.trimIndent()
            ),
            java(
                "Test.java",
                """
                package com.paulrybitskyi.hiltbinder.test;

                import com.paulrybitskyi.hiltbinder.BindType;

                import javax.inject.Named;

                @Named("test")
                @BindType(withQualifier = true)
                public class Test implements Testable {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile(
            "com/paulrybitskyi/hiltbinder/test/HiltBinder_SingletonComponentModule.java"
        )

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!
            
            package com.paulrybitskyi.hiltbinder.test;

            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;
            import javax.inject.Named;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @Named("test")
              Testable bind_com_paulrybitskyi_hiltbinder_test_Test(Test binding);
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Verify that common prefix package name is used based on bindings of component`() {
        val compilation = setupCompilation(
            java(
                "Testable1.java",
                """
                package com.paulrybitskyi.hiltbinder.testing.feature1.interfaces.testing;

                public interface Testable1 {}
                """.trimIndent()
            ),
            java(
                "Testable2.java",
                """
                package com.paulrybitskyi.hiltbinder.testing.feature2.repositories.model;

                public interface Testable2 {}
                """.trimIndent()
            ),
            java(
                "Testable3.java",
                """
                package com.paulrybitskyi.hiltbinder.testing.utils.interfaces;

                public interface Testable3 {}
                """.trimIndent()
            ),
            java(
                "Test1.java",
                """
                package com.paulrybitskyi.hiltbinder.testing.feature1.interfaces.testing;

                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType
                public class Test1 implements Testable1 {}
                """.trimIndent()
            ),
            java(
                "Test2.java",
                """
                package com.paulrybitskyi.hiltbinder.testing.feature2.repositories.model;

                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType
                public class Test2 implements Testable2 {}
                """.trimIndent()
            ),
            java(
                "Test3.java",
                """
                package com.paulrybitskyi.hiltbinder.testing.utils.interfaces;

                import com.paulrybitskyi.hiltbinder.BindType;

                @BindType
                public class Test3 implements Testable3 {}
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile(
            "com/paulrybitskyi/hiltbinder/testing/HiltBinder_SingletonComponentModule.java"
        )

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!
            
            package com.paulrybitskyi.hiltbinder.testing;

            import com.paulrybitskyi.hiltbinder.testing.feature1.interfaces.testing.Test1;
            import com.paulrybitskyi.hiltbinder.testing.feature1.interfaces.testing.Testable1;
            import com.paulrybitskyi.hiltbinder.testing.feature2.repositories.model.Test2;
            import com.paulrybitskyi.hiltbinder.testing.feature2.repositories.model.Testable2;
            import com.paulrybitskyi.hiltbinder.testing.utils.interfaces.Test3;
            import com.paulrybitskyi.hiltbinder.testing.utils.interfaces.Testable3;
            import dagger.Binds;
            import dagger.Module;
            import dagger.hilt.InstallIn;
            import dagger.hilt.components.SingletonComponent;

            @Module
            @InstallIn(SingletonComponent.class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              Testable1 bind_com_paulrybitskyi_hiltbinder_testing_feature1_interfaces_testing_Test1(
                  Test1 binding);

              @Binds
              Testable2 bind_com_paulrybitskyi_hiltbinder_testing_feature2_repositories_model_Test2(
                  Test2 binding);

              @Binds
              Testable3 bind_com_paulrybitskyi_hiltbinder_testing_utils_interfaces_Test3(Test3 binding);
            }
            """.trimIndent()
        )
    }


    private fun setupCompilation(vararg files: SourceFile): KotlinCompilation {
        val compilation = KotlinCompilation().apply {
            sources = files.toList()
            annotationProcessors = listOf(HiltBinderJavacProcessor())
            verbose = false
            inheritClassPath = true
        }

        return compilation
    }


    private fun KotlinCompilation.getGeneratedFile(path: String): File {
        return File(kaptSourceDir, path)
    }


}