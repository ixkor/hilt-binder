/*
 * Copyright 2021 Paul Rybitskyi, paul.rybitskyi.work@gmail.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.paulrybitskyi.hiltbinder.processor

import com.google.common.truth.Truth.assertThat
import com.paulrybitskyi.hiltbinder.BindType
import com.paulrybitskyi.hiltbinder.processor.ksp.model.HiltComponent
import com.paulrybitskyi.hiltbinder.processor.ksp.model.PredefinedHiltComponent
import com.paulrybitskyi.hiltbinder.processor.ksp.parser.PredefinedHiltComponentMapper
import com.paulrybitskyi.hiltbinder.processor.ksp.parser.factories.ModuleInterfaceNameFactory
import com.paulrybitskyi.hiltbinder.processor.ksp.parser.providers.MessageProvider
import com.paulrybitskyi.hiltbinder.processor.ksp.HiltBinderKspProcessorProvider
import com.paulrybitskyi.hiltbinder.processor.ksp.model.WITH_FRAGMENT_BINDINGS_TYPE_CANON_NAME
import com.tschuchort.compiletesting.KotlinCompilation
import com.tschuchort.compiletesting.KotlinCompilation.ExitCode
import com.tschuchort.compiletesting.SourceFile
import com.tschuchort.compiletesting.SourceFile.Companion.kotlin
import com.tschuchort.compiletesting.kspSourcesDir
import com.tschuchort.compiletesting.symbolProcessorProviders
import org.junit.Test
import java.io.File

internal class HiltBinderKspTest {


    private companion object {

        private val PREDEFINED_HILT_COMPONENT_MAPPER = PredefinedHiltComponentMapper()
        private val MODULE_INTERFACE_NAME_FACTORY = ModuleInterfaceNameFactory()
        private val MESSAGE_PROVIDER = MessageProvider()

        private val VALID_ANNOTATION_PREDEFINED_COMPONENTS = BindType.Component
            .values()
            .filter { (it != BindType.Component.NONE) && (it != BindType.Component.CUSTOM) }

        private val TESTABLE_FILE = kotlin("Testable.kt", "interface Testable")
        private val ABSTRACT_TEST_FILE = kotlin("AbstractTest.kt", "abstract class AbstractTest")

    }


    @Test
    fun `Binds class implicitly to its single interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!
            
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly to its single interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                
                @BindType(to = Testable::class)
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!
            
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class implicitly to its superclass`() {
        val compilation = setupCompilation(
            ABSTRACT_TEST_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                
                @BindType
                class Test : AbstractTest()
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!
            
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): AbstractTest
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly to its superclass`() {
        val compilation = setupCompilation(
            ABSTRACT_TEST_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                
                @BindType(to = AbstractTest::class)
                class Test : AbstractTest()
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!
            
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): AbstractTest
            }
            """.trimIndent()
        )
    }


    @Test
    fun `Binds class explicitly, which has two interfaces, to specific interface`() {
        val compilation = setupCompilation(
            kotlin(
                "Testable1.kt",
                "interface Testable1"
            ),
            kotlin(
                "Testable2.kt",
                "interface Testable2"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = Testable1::class)
                class Test : Testable1, Testable2
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable1
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly, which has superclass and interface, to superclass`() {
        val compilation = setupCompilation(
            ABSTRACT_TEST_FILE,
            TESTABLE_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = AbstractTest::class)
                class Test : AbstractTest(), Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): AbstractTest
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly, which has superclass and interface, to interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            ABSTRACT_TEST_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = Testable::class)
                class Test : AbstractTest(), Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo(
            """
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable
            }
            """.trimIndent())
    }


    @Test
    fun `Binds class explicitly to Any class`() {
        val compilation = setupCompilation(
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = Any::class)
                class Test
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import kotlin.Any

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Any
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly, which has superclass, to Any class`() {
        val compilation = setupCompilation(
            ABSTRACT_TEST_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = Any::class)
                class Test : AbstractTest()
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import kotlin.Any

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Any
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly, which has interface, to Any class`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = Any::class)
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import kotlin.Any

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Any
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly, which has superclass and interface, to Any class`() {
        val compilation = setupCompilation(
            ABSTRACT_TEST_FILE,
            TESTABLE_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = Any::class)
                class Test : AbstractTest(), Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import kotlin.Any

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Any
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly, which has superclass, to its superclass's implemented interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "AbstractTest.kt",
                "abstract class AbstractTest : Testable"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = Testable::class)
                class Test : AbstractTest()
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly, which has superclass, to its superclass's superclass`() {
        val compilation = setupCompilation(
            kotlin(
                "AbstractAbstractTest.kt",
                "abstract class AbstractAbstractTest"
            ),
            kotlin(
                "AbstractTest.kt",
                "abstract class AbstractTest : AbstractAbstractTest()"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = AbstractAbstractTest::class)
                class Test : AbstractTest()
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): AbstractAbstractTest
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly, which has interface, to its interface's base interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "UnitTestable.kt",
                "interface UnitTestable : Testable"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = Testable::class)
                class Test : UnitTestable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class implicitly to its parameterized interface`() {
        val compilation = setupCompilation(
            kotlin(
                "Testable.kt",
                "interface Testable<T>"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType
                class Test : Testable<Long>
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import kotlin.Long

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable<Long>
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly to its direct parameterized interface`() {
        val compilation = setupCompilation(
            kotlin(
                "Testable.kt",
                "interface Testable<T>"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = Testable::class)
                class Test : Testable<Long>
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import kotlin.Long

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable<Long>
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly to its indirect parameterized interface`() {
        val compilation = setupCompilation(
            kotlin(
                "Testable.kt",
                "interface Testable<T>"
            ),
            kotlin(
                "UnitTestable.kt",
                "interface UnitTestable : Testable<Float>"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = Testable::class)
                class Test : UnitTestable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import kotlin.Float

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable<Float>
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class implicitly to its parameterized superclass`() {
        val compilation = setupCompilation(
            kotlin(
                "AbstractTest.kt",
                "abstract class AbstractTest<T>"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType
                class Test : AbstractTest<Long>()
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import kotlin.Long

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): AbstractTest<Long>
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly to its direct parameterized superclass`() {
        val compilation = setupCompilation(
            kotlin(
                "AbstractTest.kt",
                "abstract class AbstractTest<T>"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = AbstractTest::class)
                class Test : AbstractTest<Long>()
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import kotlin.Long

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): AbstractTest<Long>
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class explicitly to its indirect parameterized superclass`() {
        val compilation = setupCompilation(
            kotlin(
                "AbstractAbstractTest.kt",
                "abstract class AbstractAbstractTest<T>"
            ),
            kotlin(
                "AbstractTest.kt",
                "abstract class AbstractTest : AbstractAbstractTest<Int>()"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                
                @BindType(to = AbstractAbstractTest::class)
                class Test : AbstractTest()
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!
            
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import kotlin.Int
            
            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): AbstractAbstractTest<Int>
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class to heavily parameterized type`() {
        val compilation = setupCompilation(
            kotlin(
                "Testable.kt",
                "interface Testable<T1, T2, T3>"
            ),
            kotlin(
                "Testable1.kt",
                "interface Testable1<T1, T2, T3>"
            ),
            kotlin(
                "Testable2.kt",
                "interface Testable2<T1, T2, T3>"
            ),
            kotlin(
                "Testable3.kt",
                "interface Testable3<T1, T2, T3>"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                
                @BindType(to = Testable::class)
                class Test : Testable<
                    Testable1<in Int, in Float, in String>,
                    Testable2<out Int, out Float, out String>,
                    Testable3<*, *, *>
                >
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import kotlin.Float
            import kotlin.Int
            import kotlin.String

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable<Testable1<Int, Float, String>, Testable2<Int, Float,
                  String>, Testable3<*, *, *>>
            }
        """.trimIndent())
    }


    @Test
    fun `Fails to bind class implicitly, which does not have superclass or interface`() {
        val compilation = setupCompilation(
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType
                class Test
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.undefinedReturnTypeError())
    }


    @Test
    fun `Fails to bind class implicitly, which has two interfaces`() {
        val compilation = setupCompilation(
            kotlin(
                "Testable1.kt",
                "interface Testable1"
            ),
            kotlin(
                "Testable2.kt",
                "interface Testable2"
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType
                class Test : Testable1, Testable2
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.undefinedReturnTypeError())
    }


    @Test
    fun `Fails to bind class implicitly, which has superclass and interface`() {
        val compilation = setupCompilation(
            ABSTRACT_TEST_FILE,
            TESTABLE_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType
                class Test : AbstractTest(), Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.undefinedReturnTypeError())
    }


    @Test
    fun `Fails to bind class explicitly, which does not have superclass or interface, to interface`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = Testable::class)
                class Test
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.noSubtypeRelationError("Test", "Testable"))
    }


    @Test
    fun `Fails to bind class explicitly, which does not have superclass or interface, to class`() {
        val compilation = setupCompilation(
            ABSTRACT_TEST_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(to = AbstractTest::class)
                class Test
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.noSubtypeRelationError("Test", "AbstractTest"))
    }


    @Test
    fun `Installs binding in predefined component, which is inferred from scope annotation`() {
        for(component in PredefinedHiltComponent.values()) {
            val isViewWithFragmentComponent = (component == PredefinedHiltComponent.VIEW_WITH_FRAGMENT)
            val withFragmentBindingAnnotation = if(isViewWithFragmentComponent) {
                "@$WITH_FRAGMENT_BINDINGS_TYPE_CANON_NAME"
            } else {
                ""
            }

            val predefinedHiltComponent = HiltComponent.Predefined(component)
            val interfaceName = MODULE_INTERFACE_NAME_FACTORY.createInterfaceName(predefinedHiltComponent)
            val compilation = setupCompilation(
                TESTABLE_FILE,
                kotlin(
                    "Test.kt",
                    """
                    import com.paulrybitskyi.hiltbinder.BindType
                    
                    @${component.scopeQualifiedName}
                    $withFragmentBindingAnnotation
                    @BindType
                    class Test : Testable
                    """.trimIndent()
                )
            )
            val result = compilation.compile()
            val generatedModule = compilation.getGeneratedFile("$interfaceName.kt")

            assertThat(result.exitCode).isEqualTo(ExitCode.OK)
            assertThat(generatedModule.exists()).isTrue()
            assertThat(generatedModule.readText()).isEqualTo(
                """
                // Generated by @BindType. Do not modify!
                
                import dagger.Binds
                import dagger.Module
                import dagger.hilt.InstallIn
                import ${component.qualifiedName}
                
                @Module
                @InstallIn(${component.simpleName}::class)
                public interface $interfaceName {
                  @Binds
                  public fun bind_Test(binding: Test): Testable
                }
                """.trimIndent()
            )
        }
    }


    @Test
    fun `Installs binding in predefined component, which is explicitly specified in annotation`() {
        for(predefinedComponent in VALID_ANNOTATION_PREDEFINED_COMPONENTS) {
            val mappedComponent = PREDEFINED_HILT_COMPONENT_MAPPER.mapToPredefinedComponent(predefinedComponent)
            val predefinedHiltComponent = HiltComponent.Predefined(mappedComponent)
            val interfaceName = MODULE_INTERFACE_NAME_FACTORY.createInterfaceName(predefinedHiltComponent)
            val compilation = setupCompilation(
                TESTABLE_FILE,
                kotlin(
                    "Test.kt",
                    """
                    import com.paulrybitskyi.hiltbinder.BindType
                    
                    @BindType(installIn = BindType.Component.${predefinedComponent.name})
                    class Test : Testable
                    """.trimIndent()
                )
            )
            val result = compilation.compile()
            val generatedModule = compilation.getGeneratedFile("$interfaceName.kt")

            assertThat(result.exitCode).isEqualTo(ExitCode.OK)
            assertThat(generatedModule.exists()).isTrue()
            assertThat(generatedModule.readText()).isEqualTo(
                """
                // Generated by @BindType. Do not modify!
                
                import dagger.Binds
                import dagger.Module
                import dagger.hilt.InstallIn
                import ${mappedComponent.qualifiedName}
                
                @Module
                @InstallIn(${mappedComponent.simpleName}::class)
                public interface $interfaceName {
                  @Binds
                  public fun bind_Test(binding: Test): Testable
                }
                """.trimIndent()
            )
        }
    }


    @Test
    fun `Installs binding in predefined component, which is specified both by the scope annotation and explicitly`() {
        for(predefinedComponent in VALID_ANNOTATION_PREDEFINED_COMPONENTS) {
            val mappedComponent = PREDEFINED_HILT_COMPONENT_MAPPER.mapToPredefinedComponent(predefinedComponent)
            val isViewWithFragmentComponent = (mappedComponent == PredefinedHiltComponent.VIEW_WITH_FRAGMENT)
            val withFragmentBindingAnnotation = if(isViewWithFragmentComponent) {
                "@$WITH_FRAGMENT_BINDINGS_TYPE_CANON_NAME"
            } else {
                ""
            }

            val predefinedHiltComponent = HiltComponent.Predefined(mappedComponent)
            val interfaceName = MODULE_INTERFACE_NAME_FACTORY.createInterfaceName(predefinedHiltComponent)
            val compilation = setupCompilation(
                TESTABLE_FILE,
                kotlin(
                    "Test.kt",
                    """
                    import com.paulrybitskyi.hiltbinder.BindType
                    
                    @${mappedComponent.scopeQualifiedName}
                    $withFragmentBindingAnnotation
                    @BindType(installIn = BindType.Component.${predefinedComponent.name})
                    class Test : Testable
                    """.trimIndent()
                )
            )
            val result = compilation.compile()
            val generatedModule = compilation.getGeneratedFile("$interfaceName.kt")

            assertThat(result.exitCode).isEqualTo(ExitCode.OK)
            assertThat(generatedModule.exists()).isTrue()
            assertThat(generatedModule.readText()).isEqualTo(
                """
                // Generated by @BindType. Do not modify!
                
                import dagger.Binds
                import dagger.Module
                import dagger.hilt.InstallIn
                import ${mappedComponent.qualifiedName}
                
                @Module
                @InstallIn(${mappedComponent.simpleName}::class)
                public interface $interfaceName {
                  @Binds
                  public fun bind_Test(binding: Test): Testable
                }
                """.trimIndent()
            )
        }
    }


    @Test
    fun `Fails to install binding in predefined component, when scope's component and explicit component differs`() {
        for(predefinedComponent in VALID_ANNOTATION_PREDEFINED_COMPONENTS) {
            val mappedComponent = PREDEFINED_HILT_COMPONENT_MAPPER.mapToPredefinedComponent(predefinedComponent)
            val isViewWithFragmentComponent = (mappedComponent == PredefinedHiltComponent.VIEW_WITH_FRAGMENT)
            val withFragmentBindingAnnotation = if(isViewWithFragmentComponent) {
                "@$WITH_FRAGMENT_BINDINGS_TYPE_CANON_NAME"
            } else {
                ""
            }
            val mismatchedExplicitComponent = when(mappedComponent) {
                PredefinedHiltComponent.SINGLETON -> PredefinedHiltComponent.ACTIVITY_RETAINED
                PredefinedHiltComponent.ACTIVITY_RETAINED -> PredefinedHiltComponent.SERVICE
                PredefinedHiltComponent.SERVICE -> PredefinedHiltComponent.ACTIVITY
                PredefinedHiltComponent.ACTIVITY -> PredefinedHiltComponent.VIEW_MODEL
                PredefinedHiltComponent.VIEW_MODEL -> PredefinedHiltComponent.FRAGMENT
                PredefinedHiltComponent.FRAGMENT -> PredefinedHiltComponent.VIEW
                PredefinedHiltComponent.VIEW -> PredefinedHiltComponent.VIEW_WITH_FRAGMENT
                PredefinedHiltComponent.VIEW_WITH_FRAGMENT -> PredefinedHiltComponent.SINGLETON
            }
            val compilation = setupCompilation(
                TESTABLE_FILE,
                kotlin(
                    "Test.kt",
                    """
                    import com.paulrybitskyi.hiltbinder.BindType
                    
                    @${mappedComponent.scopeQualifiedName}
                    $withFragmentBindingAnnotation
                    @BindType(installIn = BindType.Component.${mismatchedExplicitComponent.name})
                    class Test : Testable
                    """.trimIndent()
                )
            )
            val result = compilation.compile()

            assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
            assertThat(result.messages).contains(MESSAGE_PROVIDER.componentMismatchError())
        }
    }


    @Test
    fun `Installs scoped binding in custom component successfully`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "CustomComponent.kt",
                """
                import dagger.hilt.DefineComponent
                import dagger.hilt.components.SingletonComponent

                @CustomScope
                @DefineComponent(parent = SingletonComponent::class)
                interface CustomComponent
                """.trimIndent()
            ),
            kotlin(
                "CustomScope.kt",
                """
                import javax.inject.Scope

                @Scope
                @Retention(value = AnnotationRetention.RUNTIME)
                annotation class CustomScope
                """.trimIndent()
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(
                  installIn = BindType.Component.CUSTOM,
                  customComponent = CustomComponent::class
                )
                @CustomScope
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_CustomComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn

            @Module
            @InstallIn(CustomComponent::class)
            public interface HiltBinder_CustomComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Installs unscoped binding in custom component successfully`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "CustomComponent.kt",
                """
                import dagger.hilt.DefineComponent
                import dagger.hilt.components.SingletonComponent

                @DefineComponent(parent = SingletonComponent::class)
                interface CustomComponent
                """.trimIndent()
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(
                  installIn = BindType.Component.CUSTOM,
                  customComponent = CustomComponent::class
                )
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_CustomComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn

            @Module
            @InstallIn(CustomComponent::class)
            public interface HiltBinder_CustomComponentModule {
              @Binds
              public fun bind_Test(binding: Test): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Fails to install binding in custom component, when its type is unspecified`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(installIn = BindType.Component.CUSTOM)
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.undefinedCustomComponentError())
    }


    @Test
    fun `Binds class with predefined qualifier`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                import javax.inject.Named

                @Named("test")
                @BindType(withQualifier = true)
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import javax.inject.Named

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @Named("test")
              public fun bind_Test(binding: Test): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Binds class with custom qualifier`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "CustomQualifier.kt",
                """
                import javax.inject.Qualifier

                @Qualifier
                @Retention(AnnotationRetention.RUNTIME)
                annotation class CustomQualifier(val type: Type) {
                
                  enum class Type { ONE }
                  
                }
                """.trimIndent()
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @CustomQualifier(CustomQualifier.Type.ONE)
                @BindType(withQualifier = true)
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @CustomQualifier(CustomQualifier.Type.ONE)
              public fun bind_Test(binding: Test): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Fails to bind class, which is specified to have qualifier, but does not have it`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(withQualifier = true)
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.qualifierAbsentError())
    }


    @Test
    fun `Verify that all annotation properties are properly copied in binding method`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "CustomQualifierType.kt",
                """
                enum class CustomQualifierType {
                    
                  ONE,
                  TWO,
                  THREE
                    
                }
                """.trimIndent()
            ),
            kotlin(
                "InnerAnno.kt",
                """
                import kotlin.reflect.KClass
                    
                @Retention(AnnotationRetention.RUNTIME)
                annotation class InnerAnno(
                  val int: Int,
                  val long: Long,
                  val klass: KClass<*>
                )
                """.trimIndent()
            ),
            kotlin(
                "CustomQualifierClass.kt",
                "class CustomQualifierClass"
            ),
            kotlin(
                "CustomQualifier.kt",
                """
                import kotlin.reflect.KClass
                
                import javax.inject.Qualifier

                @Qualifier
                @Retention(AnnotationRetention.RUNTIME)
                annotation class CustomQualifier(
                  val boolean: Boolean,
                  val byte: Byte,
                  val char: Char,
                  val short: Short,
                  val int: Int,
                  val long: Long,
                  val uByte: UByte,
                  val uShort: UShort,
                  val uInt: UInt,
                  val uLong: ULong,
                  val float: Float,
                  val double: Double,
                  val string: String,
                  val enum: CustomQualifierType,
                  val annotation: InnerAnno,
                  val klass: KClass<*>,
                  val booleanArray: BooleanArray,
                  val byteArray: ByteArray,
                  val charArray: CharArray,
                  val shortArray: ShortArray,
                  val intArray: IntArray,
                  val longArray: LongArray,
                  val uByteArray: UByteArray,
                  val uShortArray: UShortArray,
                  val uIntArray: UIntArray,
                  val uLongArray: ULongArray,
                  val floatArray: FloatArray,
                  val doubleArray: DoubleArray,
                  val stringArray: Array<String>,
                  val enumArray: Array<CustomQualifierType>,
                  val annotationArray: Array<InnerAnno>,
                  val klassArray: Array<KClass<*>>
                )
                """.trimIndent()
            ),
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @CustomQualifier(
                  boolean = true,
                  byte = 10,
                  char = ',',
                  short = Short.MAX_VALUE,
                  int = -10,
                  long = 100L,
                  uByte = 18u,
                  uShort = 30u,
                  uInt = 55u,
                  uLong = 42u,
                  float = -15F,
                  double = 50.0,
                  string = "string",
                  enum = CustomQualifierType.ONE,
                  annotation = InnerAnno(
                    int = 0,
                    long = Long.MIN_VALUE,
                    klass = CustomQualifierClass::class
                  ),
                  klass = CustomQualifierClass::class,
                  booleanArray = [true, false],
                  byteArray = [100, 105],
                  charArray = ['A', 'B', 'C'],
                  shortArray = [Short.MIN_VALUE, Short.MAX_VALUE],
                  intArray = [0, 10, 20],
                  longArray = [10L, 20L, 30L],
                  uByteArray = [20u, 30u, 40u],
                  uShortArray = [30u, 40u, 50u],
                  uIntArray = [1000u, 10_000u],
                  uLongArray = [50UL, 100UL, 150UL],
                  floatArray = [Float.MAX_VALUE, Float.MIN_VALUE],
                  doubleArray = [100.0, 200.0, 300.0],
                  stringArray = ["one", "two", "three"],
                  enumArray = [
                    CustomQualifierType.ONE,
                    CustomQualifierType.TWO,
                    CustomQualifierType.THREE
                  ],
                  annotationArray = [
                    InnerAnno(
                      int = 0,
                      long = 1L,
                      klass = Int::class
                    ),
                    InnerAnno(
                      int = 10,
                      long = 100L,
                      klass = UInt::class
                    )
                  ],
                  klassArray = [
                    ByteArray::class,
                    FloatArray::class,
                    CustomQualifierClass::class
                  ]
                )
                @BindType(withQualifier = true)
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @CustomQualifier(
                boolean = true,
                byte = 10,
                char = ',',
                short = 32767,
                int = -10,
                long = 100,
                uByte = 18,
                uShort = 30,
                uInt = 55,
                uLong = 42,
                float = -15.0f,
                double = 50.0,
                string = "string",
                enum = CustomQualifierType.ONE,
                annotation = InnerAnno(int = 0, long = -9223372036854775808, klass =
                      CustomQualifierClass::class),
                klass = CustomQualifierClass::class,
                booleanArray = [true, false],
                byteArray = [100, 105],
                charArray = ['A', 'B', 'C'],
                shortArray = [-32768, 32767],
                intArray = [0, 10, 20],
                longArray = [10, 20, 30],
                uByteArray = [20, 30, 40],
                uShortArray = [30, 40, 50],
                uIntArray = [1000, 10000],
                uLongArray = [50, 100, 150],
                floatArray = [3.4028235E38f, 1.4E-45f],
                doubleArray = [100.0, 200.0, 300.0],
                stringArray = ["one", "two", "three"],
                enumArray = [CustomQualifierType.ONE, CustomQualifierType.TWO, CustomQualifierType.THREE],
                annotationArray = [InnerAnno(int = 0, long = 1, klass = kotlin.Int::class), InnerAnno(int = 10,
                    long = 100, klass = kotlin.UInt::class)],
                klassArray = [kotlin.ByteArray::class, kotlin.FloatArray::class, CustomQualifierClass::class]
              )
              public fun bind_Test(binding: Test): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Saves bound classes into multibound set`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test1.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(contributesTo = BindType.Collection.SET)
                class Test1 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(contributesTo = BindType.Collection.SET)
                class Test2 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(contributesTo = BindType.Collection.SET)
                class Test3 : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import dagger.multibindings.IntoSet

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoSet
              public fun bind_Test1(binding: Test1): Testable

              @Binds
              @IntoSet
              public fun bind_Test2(binding: Test2): Testable

              @Binds
              @IntoSet
              public fun bind_Test3(binding: Test3): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Saves bound parameterized classes into multibound set`() {
        val compilation = setupCompilation(
            kotlin(
                "Testable.kt",
                "interface Testable<T1>"
            ),
            kotlin(
                "Test1.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(contributesTo = BindType.Collection.SET)
                class Test1 : Testable<Int>
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(contributesTo = BindType.Collection.SET)
                class Test2 : Testable<Long>
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(contributesTo = BindType.Collection.SET)
                class Test3 : Testable<Float>
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import dagger.multibindings.IntoSet

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoSet
              public fun bind_Test1(binding: Test1): Testable<*>

              @Binds
              @IntoSet
              public fun bind_Test2(binding: Test2): Testable<*>

              @Binds
              @IntoSet
              public fun bind_Test3(binding: Test3): Testable<*>
            }
        """.trimIndent())
    }


    @Test
    fun `Saves bound classes into qualified multibound set`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test1.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                import javax.inject.Named

                @Named("one")
                @BindType(
                  contributesTo = BindType.Collection.SET,
                  withQualifier = true
                )
                class Test1 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                import javax.inject.Named

                @Named("two")
                @BindType(
                  contributesTo = BindType.Collection.SET,
                  withQualifier = true
                )
                class Test2 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                import javax.inject.Named

                @Named("three")
                @BindType(
                  contributesTo = BindType.Collection.SET,
                  withQualifier = true
                )
                class Test3 : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import dagger.multibindings.IntoSet
            import javax.inject.Named

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoSet
              @Named("one")
              public fun bind_Test1(binding: Test1): Testable

              @Binds
              @IntoSet
              @Named("two")
              public fun bind_Test2(binding: Test2): Testable

              @Binds
              @IntoSet
              @Named("three")
              public fun bind_Test3(binding: Test3): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Fails to save bound class, which does not have @MapKey annotation, into multibound map`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @BindType(contributesTo = BindType.Collection.MAP)
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()

        assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
        assertThat(result.messages).contains(MESSAGE_PROVIDER.noMapKeyError())
    }


    @Test
    fun `Saves bound classes into multibound map using standard integer key annotation`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test1.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapIntKey

                @MapIntKey(1)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test1 : Testable 
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapIntKey

                @MapIntKey(2)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test2 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapIntKey

                @MapIntKey(3)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test3 : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapIntKey
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import dagger.multibindings.IntoMap

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapIntKey(1)
              public fun bind_Test1(binding: Test1): Testable

              @Binds
              @IntoMap
              @MapIntKey(2)
              public fun bind_Test2(binding: Test2): Testable

              @Binds
              @IntoMap
              @MapIntKey(3)
              public fun bind_Test3(binding: Test3): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Saves bound classes into multibound map using standard long key annotation`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test1.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapLongKey

                @MapLongKey(1L)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test1 : Testable 
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapLongKey

                @MapLongKey(2L)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test2 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapLongKey

                @MapLongKey(3L)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test3 : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapLongKey
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import dagger.multibindings.IntoMap

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapLongKey(1)
              public fun bind_Test1(binding: Test1): Testable

              @Binds
              @IntoMap
              @MapLongKey(2)
              public fun bind_Test2(binding: Test2): Testable

              @Binds
              @IntoMap
              @MapLongKey(3)
              public fun bind_Test3(binding: Test3): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Saves bound classes into multibound map using standard string key annotation`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test1.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapStringKey

                @MapStringKey("one")
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test1 : Testable 
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapStringKey

                @MapStringKey("two")
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test2 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapStringKey

                @MapStringKey("three")
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test3 : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapStringKey
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import dagger.multibindings.IntoMap

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapStringKey("one")
              public fun bind_Test1(binding: Test1): Testable

              @Binds
              @IntoMap
              @MapStringKey("two")
              public fun bind_Test2(binding: Test2): Testable

              @Binds
              @IntoMap
              @MapStringKey("three")
              public fun bind_Test3(binding: Test3): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Saves bound classes into multibound map using standard class key annotation`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test1.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey

                @MapClassKey(Test1::class)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test1 : Testable 
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey

                @MapClassKey(Test2::class)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test2 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey

                @MapClassKey(Test3::class)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test3 : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapClassKey
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import dagger.multibindings.IntoMap

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapClassKey(Test1::class)
              public fun bind_Test1(binding: Test1): Testable

              @Binds
              @IntoMap
              @MapClassKey(Test2::class)
              public fun bind_Test2(binding: Test2): Testable

              @Binds
              @IntoMap
              @MapClassKey(Test3::class)
              public fun bind_Test3(binding: Test3): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Saves bound parameterized classes into multibound map using standard class key annotation`() {
        val compilation = setupCompilation(
            kotlin(
                "Testable.kt",
                "interface Testable<T1, T2>"
            ),
            kotlin(
                "Test1.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey

                @MapClassKey(Test1::class)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test1 : Testable<Long, Long>
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey

                @MapClassKey(Test2::class)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test2 : Testable<Int, Int>
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey

                @MapClassKey(Test3::class)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test3 : Testable<Float, Float>
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapClassKey
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import dagger.multibindings.IntoMap

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapClassKey(Test1::class)
              public fun bind_Test1(binding: Test1): Testable<*, *>

              @Binds
              @IntoMap
              @MapClassKey(Test2::class)
              public fun bind_Test2(binding: Test2): Testable<*, *>

              @Binds
              @IntoMap
              @MapClassKey(Test3::class)
              public fun bind_Test3(binding: Test3): Testable<*, *>
            }
        """.trimIndent())

    }


    @Test
    fun `Saves bound classes into multibound map using custom @MapKey annotation`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "TestMapKey.kt",
                """
                import dagger.MapKey
                
                @MapKey
                @Retention(AnnotationRetention.RUNTIME)
                annotation class TestMapKey(val value: Type) {
                    
                  enum class Type {

                    ONE,
                    TWO,
                    THREE

                  }

                }
                """.trimIndent()
            ),
            kotlin(
                "Test1.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @TestMapKey(TestMapKey.Type.ONE)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test1 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @TestMapKey(TestMapKey.Type.TWO)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test2 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @TestMapKey(TestMapKey.Type.THREE)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test3 : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import dagger.multibindings.IntoMap

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.ONE)
              public fun bind_Test1(binding: Test1): Testable

              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.TWO)
              public fun bind_Test2(binding: Test2): Testable

              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.THREE)
              public fun bind_Test3(binding: Test3): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Saves bound parameterized classes into multibound map using custom @MapKey annotation`() {
        val compilation = setupCompilation(
            kotlin(
                "Testable.kt",
                "interface Testable<T1, T2, T3>"
            ),
            kotlin(
                "TestMapKey.kt",
                """
                import dagger.MapKey
                
                @MapKey
                @Retention(AnnotationRetention.RUNTIME)
                annotation class TestMapKey(val value: Type) {
                    
                  enum class Type {

                    ONE,
                    TWO,
                    THREE

                  }

                }
                """.trimIndent()
            ),
            kotlin(
                "Test1.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @TestMapKey(TestMapKey.Type.ONE)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test1 : Testable<Int, Int, Int>
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @TestMapKey(TestMapKey.Type.TWO)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test2 : Testable<Float, Float, Float>
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType

                @TestMapKey(TestMapKey.Type.THREE)
                @BindType(contributesTo = BindType.Collection.MAP)
                class Test3 : Testable<Double, Double, Double>
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import dagger.multibindings.IntoMap

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.ONE)
              public fun bind_Test1(binding: Test1): Testable<*, *, *>

              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.TWO)
              public fun bind_Test2(binding: Test2): Testable<*, *, *>

              @Binds
              @IntoMap
              @TestMapKey(TestMapKey.Type.THREE)
              public fun bind_Test3(binding: Test3): Testable<*, *, *>
            }
        """.trimIndent())
    }


    @Test
    fun `Saves bound classes into qualified multibound map`() {
        val compilation = setupCompilation(
            TESTABLE_FILE,
            kotlin(
                "Test1.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey

                import javax.inject.Named

                @BindType(
                  contributesTo = BindType.Collection.MAP,
                  withQualifier = true
                )
                @MapClassKey(Test1::class)
                @Named("one")
                class Test1 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey

                import javax.inject.Named

                @BindType(
                  contributesTo = BindType.Collection.MAP,
                  withQualifier = true
                )
                @MapClassKey(Test2::class)
                @Named("two")
                class Test2 : Testable
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                import com.paulrybitskyi.hiltbinder.BindType
                import com.paulrybitskyi.hiltbinder.keys.MapClassKey
                
                import javax.inject.Named
                
                @BindType(
                  contributesTo = BindType.Collection.MAP,
                  withQualifier = true
                )
                @MapClassKey(Test3::class)
                @Named("three")
                class Test3 : Testable   
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile("HiltBinder_SingletonComponentModule.kt")

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!

            import com.paulrybitskyi.hiltbinder.keys.MapClassKey
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import dagger.multibindings.IntoMap
            import javax.inject.Named

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @IntoMap
              @MapClassKey(Test1::class)
              @Named("one")
              public fun bind_Test1(binding: Test1): Testable

              @Binds
              @IntoMap
              @MapClassKey(Test2::class)
              @Named("two")
              public fun bind_Test2(binding: Test2): Testable

              @Binds
              @IntoMap
              @MapClassKey(Test3::class)
              @Named("three")
              public fun bind_Test3(binding: Test3): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Verify that binding method is properly formatted`() {
        val compilation = setupCompilation(
            kotlin(
                "Testable.kt",
                """
                package com.paulrybitskyi.hiltbinder.test

                interface Testable
                """.trimIndent()
            ),
            kotlin(
                "Test.kt",
                """
                package com.paulrybitskyi.hiltbinder.test

                import com.paulrybitskyi.hiltbinder.BindType

                import javax.inject.Named

                @Named("test")
                @BindType(withQualifier = true)
                class Test : Testable
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile(
            "com/paulrybitskyi/hiltbinder/test/HiltBinder_SingletonComponentModule.kt"
        )

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!
            
            package com.paulrybitskyi.hiltbinder.test

            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent
            import javax.inject.Named

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              @Named("test")
              public fun bind_com_paulrybitskyi_hiltbinder_test_Test(binding: Test): Testable
            }
        """.trimIndent())
    }


    @Test
    fun `Verify that common prefix package name is used based on bindings of component`() {
        val compilation = setupCompilation(
            kotlin(
                "Testable1.kt",
                """
                package com.paulrybitskyi.hiltbinder.testing.feature1.interfaces.testing

                interface Testable1
                """.trimIndent()
            ),
            kotlin(
                "Testable2.kt",
                """
                package com.paulrybitskyi.hiltbinder.testing.feature2.repositories.model

                interface Testable2
                """.trimIndent()
            ),
            kotlin(
                "Testable3.kt",
                """
                package com.paulrybitskyi.hiltbinder.testing.utils.interfaces

                interface Testable3
                """.trimIndent()
            ),
            kotlin(
                "Test1.kt",
                """
                package com.paulrybitskyi.hiltbinder.testing.feature1.interfaces.testing

                import com.paulrybitskyi.hiltbinder.BindType

                @BindType
                class Test1 : Testable1
                """.trimIndent()
            ),
            kotlin(
                "Test2.kt",
                """
                package com.paulrybitskyi.hiltbinder.testing.feature2.repositories.model

                import com.paulrybitskyi.hiltbinder.BindType

                @BindType
                class Test2 : Testable2
                """.trimIndent()
            ),
            kotlin(
                "Test3.kt",
                """
                package com.paulrybitskyi.hiltbinder.testing.utils.interfaces

                import com.paulrybitskyi.hiltbinder.BindType

                @BindType
                class Test3 : Testable3
                """.trimIndent()
            )
        )
        val result = compilation.compile()
        val generatedModule = compilation.getGeneratedFile(
            "com/paulrybitskyi/hiltbinder/testing/HiltBinder_SingletonComponentModule.kt"
        )

        assertThat(result.exitCode).isEqualTo(ExitCode.OK)
        assertThat(generatedModule.exists()).isTrue()
        assertThat(generatedModule.readText()).isEqualTo("""
            // Generated by @BindType. Do not modify!
            
            package com.paulrybitskyi.hiltbinder.testing

            import com.paulrybitskyi.hiltbinder.testing.feature1.interfaces.testing.Test1
            import com.paulrybitskyi.hiltbinder.testing.feature1.interfaces.testing.Testable1
            import com.paulrybitskyi.hiltbinder.testing.feature2.repositories.model.Test2
            import com.paulrybitskyi.hiltbinder.testing.feature2.repositories.model.Testable2
            import com.paulrybitskyi.hiltbinder.testing.utils.interfaces.Test3
            import com.paulrybitskyi.hiltbinder.testing.utils.interfaces.Testable3
            import dagger.Binds
            import dagger.Module
            import dagger.hilt.InstallIn
            import dagger.hilt.components.SingletonComponent

            @Module
            @InstallIn(SingletonComponent::class)
            public interface HiltBinder_SingletonComponentModule {
              @Binds
              public
                  fun bind_com_paulrybitskyi_hiltbinder_testing_feature1_interfaces_testing_Test1(binding: Test1):
                  Testable1

              @Binds
              public
                  fun bind_com_paulrybitskyi_hiltbinder_testing_feature2_repositories_model_Test2(binding: Test2):
                  Testable2

              @Binds
              public fun bind_com_paulrybitskyi_hiltbinder_testing_utils_interfaces_Test3(binding: Test3):
                  Testable3
            }
        """.trimIndent())
    }


    private fun setupCompilation(vararg files: SourceFile): KotlinCompilation {
        val compilation = KotlinCompilation().apply {
            sources = files.toList()
            symbolProcessorProviders = listOf(HiltBinderKspProcessorProvider())
            verbose = false
            inheritClassPath = true
        }

        return compilation
    }


    private fun KotlinCompilation.getGeneratedFile(path: String): File {
        return File(kspSourcesDir, "kotlin/$path")
    }


}